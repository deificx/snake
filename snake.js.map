{"version":3,"sources":["webpack://snake/./node_modules/mousetrap/mousetrap.js","webpack://snake/webpack/bootstrap","webpack://snake/webpack/runtime/compat get default export","webpack://snake/webpack/runtime/define property getters","webpack://snake/webpack/runtime/hasOwnProperty shorthand","webpack://snake/./src/constants.js","webpack://snake/./src/html.js","webpack://snake/./src/controls.js","webpack://snake/./src/game.js","webpack://snake/./src/snake.js","webpack://snake/./src/textRenderer.js"],"names":["window","document","undefined","_REVERSE_MAP","_MAP","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","_KEYCODE_MAP","106","107","109","110","111","186","187","188","189","190","191","192","219","220","221","222","_SHIFT_MAP","_SPECIAL_ALIASES","test","navigator","platform","i","toString","Mousetrap","prototype","bind","keys","callback","action","self","this","Array","_bindMultiple","call","unbind","trigger","_directMap","reset","_callbacks","stopCallback","e","element","className","indexOf","_belongsTo","target","composedPath","initialEventTarget","tagName","isContentEditable","handleKey","_handleKey","apply","arguments","addKeycodes","object","key","hasOwnProperty","init","documentMousetrap","method","charAt","module","exports","define","_addEvent","type","addEventListener","attachEvent","_characterFromEvent","character","String","fromCharCode","which","shiftKey","toLowerCase","_isModifier","_pickBestAction","modifiers","_getReverseMap","length","_getKeyInfo","combination","replace","split","_keysFromString","push","ancestor","parentNode","targetElement","_resetTimer","_sequenceLevels","_ignoreNextKeyup","_ignoreNextKeypress","_nextExpectedAction","_resetSequences","doNotReset","activeSequences","_getMatches","sequenceName","level","modifiers1","modifiers2","matches","seq","metaKey","ctrlKey","sort","join","deleteCombo","combo","deleteSequence","splice","_fireCallback","sequence","srcElement","preventDefault","returnValue","_preventDefault","stopPropagation","cancelBubble","_stopPropagation","_handleKeyEvent","keyCode","altKey","_eventModifiers","_bindSingle","info","_increaseSequence","nextAction","clearTimeout","setTimeout","_callbackAndReset","wrappedCallback","_bindSequence","callbacks","maxLevel","processedSequenceCallback","Math","max","ignoreThisKeypress","combinations","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","n","getter","__esModule","d","a","definition","o","Object","defineProperty","enumerable","get","obj","prop","UP","RIGHT","DOWN","LEFT","IDLE","ENDED","COOLDOWN","EMIT_MOVE","EMIT_NEW_GAME","canvas","getElementById","body","style","margin","height","width","offsetWidth","offsetHeight","events","constructor","createElement","emit","name","detail","dispatchEvent","CustomEvent","on","handler","event","direction","s","gridWidth","c","getContext","grid","w","h","round","state","radius","apple","x","y","position","score","snake","wait","cooldown","newGame","randomDir","placeApple","setDir","dir","getState","getScore","floor","random","collision","pos","randomPos","move","same","pop","unshift","from","directionDiff","to","update","dt","assign","b","abs","render","percentage","entering","offsetX","offsetY","fillStyle","fillRect","strokeStyle","moveTo","lineTo","stroke","beginPath","arc","PI","closePath","fill","renderText","context","textWidth","textMarginLeft","line","text","font","fillText","textRenderer","time","now","Date","getTime","requestAnimationFrame","controls"],"mappings":"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","file":"snake.js","sourcesContent":["/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.5\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n        // not the initial event target in the shadow tree. Note that not all events cross the\n        // shadow boundary.\n        // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n        // the events composed path. For shadow trees with `mode: 'closed'`, the initial event\n        // target cannot be obtained.\n        if ('composedPath' in e && typeof e.composedPath === 'function') {\n            // For open shadow trees, update `element` so that the following check works.\n            var initialEventTarget = e.composedPath()[0];\n            if (initialEventTarget !== e.target) {\n                element = initialEventTarget;\n            }\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","\"use strict\";\n\nexport const UP = \"UP\";\nexport const RIGHT = \"RIGHT\";\nexport const DOWN = \"DOWN\";\nexport const LEFT = \"LEFT\";\n\nexport const IDLE = \"IDLE\";\nexport const STARTED = \"STARTED\";\nexport const ENDED = \"ENDED\";\n\nexport const COOLDOWN = 250;\nexport const SCORE_CAP = 150;\nexport const SCORE_INCREASE = 10;\n\nexport const EMIT_MOVE = \"EMIT_MOVE\";\nexport const EMIT_NEW_GAME = \"EMIT_NEW_GAME\";\n","\"use strict\";\n\nconst canvas = document.getElementById(\"snake\");\n\ndocument.body.style.margin = \"0px\";\ndocument.body.style.height = \"100vh\";\n\ncanvas.width = document.body.offsetWidth;\ncanvas.height = document.body.offsetHeight;\n\nexport default canvas;\n","\"use strict\";\n\nimport { UP, RIGHT, DOWN, LEFT, EMIT_MOVE, EMIT_NEW_GAME } from \"./constants\";\n\nclass EventEmitter {\n  constructor() {\n    this.element = window.document.createElement(\"a\");\n  }\n\n  emit(name, detail = {}) {\n    this.element.dispatchEvent(new window.CustomEvent(name, { detail }));\n  }\n\n  on(name, handler) {\n    this.element.addEventListener(name, (event) => {\n      handler(event.detail);\n    });\n  }\n}\n\nconst events = new EventEmitter();\n\nimport Mousetrap from \"mousetrap\";\n\nMousetrap.bind(\"up\", () => {\n  events.emit(EMIT_MOVE, { direction: UP });\n});\nMousetrap.bind(\"right\", () => {\n  events.emit(EMIT_MOVE, { direction: RIGHT });\n});\nMousetrap.bind(\"down\", () => {\n  events.emit(EMIT_MOVE, { direction: DOWN });\n});\nMousetrap.bind(\"left\", () => {\n  events.emit(EMIT_MOVE, { direction: LEFT });\n});\nMousetrap.bind(\"enter\", () => {\n  events.emit(EMIT_NEW_GAME);\n});\nMousetrap.bind(\"space\", () => events.emit(EMIT_NEW_GAME));\n\nexport default events;\n","\"use strict\";\n\nimport { IDLE, ENDED, EMIT_MOVE, EMIT_NEW_GAME } from \"./constants\";\n\nimport canvas from \"./html.js\";\nimport Snake from \"./snake\";\nimport textRenderer from \"./textRenderer\";\n\nconst gridWidth = 30;\nconst s = new Snake(canvas, gridWidth);\n\nconst renderText = textRenderer(canvas);\n\nlet highScore = 0;\nlet time;\n\nconst render = () => {\n  const now = new Date().getTime();\n  const dt = now - (time || now);\n  time = now;\n\n  s.update(dt);\n  s.render();\n\n  switch (s.getState()) {\n    case IDLE:\n      renderText({\n        text: \"Press return/enter to start a new game\",\n      });\n      break;\n\n    case ENDED:\n      renderText({ text: \"GAME OVER!\" });\n      renderText({ text: \"Press return/enter to start a new game\", line: 2 });\n      if (s.getScore() > 0 && s.getScore() >= highScore) {\n        renderText({\n          text: `Congratulations, new high score: ${s.getScore()}`,\n          line: 3,\n        });\n      } else {\n        renderText({\n          text: `You scored ${s.getScore()} points. Your high score is ${highScore}`,\n          line: 3,\n        });\n      }\n      break;\n\n    default:\n      renderText({\n        text: s.getScore(),\n      });\n      requestAnimationFrame(render);\n      break;\n  }\n};\n\nrequestAnimationFrame(render);\n\nimport controls from \"./controls\";\n\ncontrols.on(EMIT_MOVE, ({ direction }) => {\n  s.setDir(direction);\n});\ncontrols.on(EMIT_NEW_GAME, () => {\n  s.newGame();\n  requestAnimationFrame(render);\n});\n","\"use strict\";\n\nimport {\n  UP,\n  RIGHT,\n  DOWN,\n  LEFT,\n  IDLE,\n  STARTED,\n  ENDED,\n  SCORE_CAP,\n  SCORE_INCREASE,\n  COOLDOWN,\n} from \"./constants\";\n\nexport default class Snake {\n  constructor(canvas, gridWidth) {\n    this.c = canvas.getContext(\"2d\");\n    this.width = canvas.width;\n    this.height = canvas.height;\n\n    this.grid = {\n      w: gridWidth,\n      h: Math.round((gridWidth / this.width) * this.height),\n    };\n    this.state = IDLE;\n    this.radius = Math.round(this.width / gridWidth) / 2;\n\n    this.apple = {\n      x: null,\n      y: null,\n    };\n    this.position = {\n      x: null,\n      y: null,\n    };\n    this.direction = null;\n    this.score = 0;\n\n    this.snake = [];\n    this.wait = COOLDOWN;\n    this.cooldown = COOLDOWN;\n  }\n\n  newGame() {\n    this.snake = [];\n    this.snake.push({\n      x: Math.round(this.grid.w / 2),\n      y: Math.round(this.grid.h / 2),\n    });\n    this.snake.push(this.snake[0]);\n    this.snake.push(this.snake[0]);\n\n    this.position = this.snake[0];\n    this.randomDir();\n\n    this.placeApple();\n\n    this.score = 0;\n    this.state = STARTED;\n    this.wait = COOLDOWN;\n    this.cooldown = COOLDOWN;\n  }\n\n  setDir(dir) {\n    this.direction = dir;\n  }\n\n  getState() {\n    return this.state;\n  }\n\n  getScore() {\n    return this.score;\n  }\n\n  randomDir() {\n    const cases = 3;\n    switch (Math.floor(Math.random() * cases)) {\n      case 0:\n        this.direction = UP;\n        return UP;\n      case 1:\n        this.direction = LEFT;\n        return LEFT;\n      case 2:\n        this.direction = DOWN;\n        return DOWN;\n      default:\n        this.direction = null;\n        return null;\n    }\n  }\n\n  collision(pos) {\n    var i;\n    for (i = 0; i < this.snake.length; i++) {\n      if (pos.x === this.snake[i].x && pos.y === this.snake[i].y) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  randomPos() {\n    return {\n      x: Math.floor(Math.random() * this.grid.w),\n      y: Math.floor(Math.random() * this.grid.h),\n    };\n  }\n\n  placeApple() {\n    var apple = this.randomPos();\n    while (this.collision(apple)) {\n      apple = this.randomPos();\n    }\n    this.apple = apple;\n  }\n\n  move(move, same) {\n    this.position = move;\n    if (same) {\n      this.snake.pop();\n    }\n    this.snake.unshift(move);\n    this.snake[0].from = this.directionDiff(this.snake[1], this.snake[0]);\n    this.snake[1].from = this.directionDiff(this.snake[2], this.snake[1]);\n    this.snake[1].to = this.directionDiff(this.snake[0], this.snake[1]);\n  }\n\n  update(dt) {\n    const move = Object.assign({}, this.position);\n\n    this.wait = this.wait - dt;\n\n    if (this.wait > 0) {\n      return;\n    }\n\n    this.wait = this.cooldown;\n\n    switch (this.direction) {\n      case UP:\n        move.y = move.y - 1;\n        if (move.y < 0) {\n          move.y = this.grid.h - 1;\n        }\n        break;\n      case RIGHT:\n        move.x = move.x + 1;\n        if (move.x >= this.grid.w) {\n          move.x = 0;\n        }\n        break;\n      case DOWN:\n        move.y = move.y + 1;\n        if (move.y >= this.grid.h) {\n          move.y = 0;\n        }\n        break;\n      case LEFT:\n        move.x = move.x - 1;\n        if (move.x < 0) {\n          move.x = this.grid.w - 1;\n        }\n        break;\n      default:\n        break;\n    }\n\n    if (move.x === this.apple.x && move.y === this.apple.y) {\n      this.score = this.score + SCORE_INCREASE;\n      if (this.score < SCORE_CAP) {\n        this.cooldown = COOLDOWN - this.score;\n      }\n      this.placeApple();\n      this.move(move, false);\n    } else if (this.collision(move)) {\n      this.wait = 0;\n      this.state = ENDED;\n    } else {\n      this.move(move, true);\n    }\n  }\n\n  directionDiff(a, b) {\n    if (Math.abs(a.x - b.x) > 1 || Math.abs(a.y - b.y) > 1) {\n      if (a.x < b.x) {\n        return RIGHT;\n      } else if (a.x > b.x) {\n        return LEFT;\n      } else if (a.y < b.y) {\n        return DOWN;\n      }\n      return UP;\n    } else {\n      if (a.x < b.x) {\n        return LEFT;\n      } else if (a.x > b.x) {\n        return RIGHT;\n      } else if (a.y < b.y) {\n        return UP;\n      }\n      return DOWN;\n    }\n  }\n\n  render() {\n    if (this.state === IDLE) {\n      return;\n    }\n\n    const percentage = ((this.cooldown - this.wait) / this.cooldown) * 2;\n    const entering = this.wait > this.cooldown / 2;\n\n    let i;\n    let offsetX;\n    let offsetY;\n\n    this.c.fillStyle = \"#eee\";\n    this.c.fillRect(0, 0, this.width, this.height);\n\n    this.c.strokeStyle = \"#ccc\";\n    for (i = 1; i < this.grid.w; i++) {\n      this.c.moveTo(this.radius * 2 * i, 0);\n      this.c.lineTo(this.radius * 2 * i, this.height);\n    }\n    for (i = 1; i < this.grid.h; i++) {\n      this.c.moveTo(0, this.radius * 2 * i);\n      this.c.lineTo(this.width, this.radius * 2 * i);\n    }\n    this.c.stroke();\n\n    this.c.fillStyle = \"#f00\";\n    this.c.beginPath();\n    this.c.arc(\n      this.apple.x * this.radius * 2 + this.radius,\n      this.apple.y * this.radius * 2 + this.radius,\n      this.radius,\n      0,\n      Math.PI * 2\n    );\n    this.c.closePath();\n    this.c.fill();\n\n    this.c.fillStyle = \"#333\";\n\n    for (i = 0; i < this.snake.length; i++) {\n      offsetX = 0;\n      offsetY = 0;\n      if (entering) {\n        switch (this.snake[i].from) {\n          case UP:\n            offsetY = this.radius * percentage - this.radius;\n            break;\n          case DOWN:\n            offsetY = this.radius * percentage * -1 + this.radius;\n            break;\n          case LEFT:\n            offsetX = this.radius * percentage - this.radius;\n            break;\n          case RIGHT:\n            offsetX = this.radius * percentage * -1 + this.radius;\n            break;\n        }\n      } else {\n        switch (this.snake[i].to || this.direction) {\n          case UP:\n            offsetY = this.radius * percentage * -1 + this.radius;\n            break;\n          case DOWN:\n            offsetY = this.radius * percentage - this.radius;\n            break;\n          case LEFT:\n            offsetX = this.radius * percentage * -1 + this.radius;\n            break;\n          case RIGHT:\n            offsetX = this.radius * percentage - this.radius;\n            break;\n        }\n      }\n\n      this.c.beginPath();\n      this.c.arc(\n        this.snake[i].x * this.radius * 2 + offsetX + this.radius,\n        this.snake[i].y * this.radius * 2 + offsetY + this.radius,\n        this.radius,\n        0,\n        Math.PI * 2\n      );\n      this.c.closePath();\n      this.c.fill();\n    }\n  }\n}\n","export default function textRenderer(canvas) {\n  const context = canvas.getContext(\"2d\");\n  const textMarginLeft = 20;\n  const textHeight = 50;\n  const textWidth = canvas.width - textMarginLeft * 2;\n\n  return function ({ line = 1, text }) {\n    context.fillStyle = \"#999\";\n    context.font = \"32px sans-serif\";\n    context.fillText(text, textMarginLeft, textHeight * line, textWidth);\n  };\n}\n"],"sourceRoot":""}